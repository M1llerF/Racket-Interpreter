This document contains information on the way certain functions work

HOW DOES ARITHEMETIC WORK?
Example: 
Consider: (startEval '(+ (* 2 3) 4) '())
1. startEval see's (+ (* 2 3) 4).
2. It identifies it as a list so it calls eval_arith
3. Inside eval_arith we do a couple things:
    - let* first binds arg1 to the result of (* 2 3)
    - Then, let* binds arg2 to 4 (evaluating caddr expr)
    - The + operation is applied to arg1 and arg2, yielding 10

HOW ARE OPERATORS AND OPERANDS ASSIGNED?
1. eval-list identifies the operator
    - (car expr) extracts the first element of the list as the operator
    - In (+ (* 2 3) 4), the first element is +
2. eval-arith Evaluates Operands Sequentially
    - The operands are assumed to be the second and third elements of the list
      extracted using (cadr expr) and (caddr expr)
    - So in (+ (* 2 3) 4)
        - (* 2 3) is the first operand (cadr expr), and evaluates to 6
        - (/ 10 5) is the second operand (caddr expr), and evaulates to 2
3. Apply the operation
    - The last step is to apply + operation to arg1 (6) and arg2 (2),
      which yields 8

HOW DOES BEDMAS WORK?
It doesn't! For Racket which is a Lisp-like language it handles arithemetic
through prefix notation and explicit parentheses. This means that racket does
not have a implicit precedence for evaluating operations (all precedence is explicit)